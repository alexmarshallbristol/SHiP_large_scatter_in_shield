muons.root";

  fLogger = FairLogger::GetLogger();
  fLogger->Info(MESSAGE_ORIGIN,"Opening input file %s",fileName);
  TFile* fInputFile  = new TFile(fileName);

  fn = 0;
  Bool_t fPhiRandomize = true;
  Int_t fSameSeed = 0;
  Int_t fsmearBeam = 0;

fTree = (TTree *)fInputFile->Get("pythia8-Geant4");
   fNevents   = fTree->GetEntries();

   std::cout << "fNevents " << fNevents <<"\n";
   Double_t fUniquieID,fPdgCode,fMotherId,fPx,fPy,fPz,fM,fStartX,fStartY,fStartZ,fW,fProcID;

  fTree->SetBranchAddress("pythiaid",&fPdgCode);
  fTree->SetBranchAddress("mother_id",&fMotherId);
  fTree->SetBranchAddress("px",&fPx);
  fTree->SetBranchAddress("py",&fPy);
  fTree->SetBranchAddress("pz",&fPz);
  fTree->SetBranchAddress("x",&fStartX);
  fTree->SetBranchAddress("y",&fStartY);
  fTree->SetBranchAddress("z",&fStartZ);
  fTree->SetBranchAddress("w",&fW);
  fTree->SetBranchAddress("process_id",&fProcID);

  // cout << "/afs/cern.ch/user/a/amarshal/GEANT_fairship_geo/muons.root" << endl;






//   fPythiaP =  new Pythia8::Pythia(); // pythia needed also for G4only, to copy 2mu BRs
//   if (Option == "Primary" && !G4only){
//    fPythiaN =  new Pythia8::Pythia();
//   }else if (Option != "charm" && Option != "beauty" && !G4only) {
//    fLogger->Error(MESSAGE_ORIGIN,"Option not known %s, abort",Option.Data());
//   }
//   if (fUseRandom1) fRandomEngine = new PyTr1Rng();
//   if (fUseRandom3) fRandomEngine = new PyTr3Rng();
//   std::vector<int> r = { 221, 221, 223, 223,   113, 331, 333};
//   std::vector<int> c = {  6 ,  7,   5 ,  7,     5,   6,   9}; // decay channel mumu mumuX

//   if (Option == "Primary" && !G4only){
//    fPythiaP->settings.mode("Beams:idB",  2212);
//    fPythiaN->settings.mode("Beams:idB",  2112);
//   }else{
//    fPythiaP->readString("ProcessLevel:all = off");
//   }
//   std::array<Pythia8::Pythia*,2> plist = {fPythiaP,fPythiaN};
//   Int_t pcount = 0;
//   for(const auto& fPythia : plist) {
//    if (pcount > 0 && (Option != "Primary" || G4only)){continue;}
//    pcount+=1; 
//    fPythia->setRndmEnginePtr(fRandomEngine);
//    fPythia->settings.mode("Random:seed",fSeed);
//    fPythia->settings.mode("Next:numberCount",heartbeat);
//    if (Option == "Primary"){
//     fPythia->settings.mode("Beams:idA",  2212);
//     fPythia->settings.mode("Beams:frameType",  2);
//     fPythia->settings.parm("Beams:eA",fMom);
//     fPythia->settings.parm("Beams:eB",0.);
//     if (JpsiMainly){
// // use this for all onia productions
//      fPythia->readString("Onia:all(3S1) = on");
//      fPythia->readString("443:new  J/psi  J/psi  3   0   0    3.09692    0.00009    3.09602    3.09782  0.   1   1   0   1   0");
//      fPythia->readString("443:addChannel = 1   1.    0      -13       13");
//      fPythia->readString("553:new  Upsilon  Upsilon  3   0   0    9.46030    0.00005    9.45980    9.46080  0.00000e+00   0   1   0   1   0");
//      fPythia->readString("553:addChannel = 1   1.    0      -13       13");
//     }else{
//      fPythia->readString("SoftQCD:inelastic = on");
//      fPythia->readString("PhotonCollision:gmgm2mumu = on");
//      fPythia->readString("PromptPhoton:all = on");
//      fPythia->readString("WeakBosonExchange:all = on");
//     }
//    }
//    if (tauOnly){
//     fPythia->readString("431:new  D_s+  D_s-  1   3   0    1.96849    0.00000    0.00000    0.00000  1.49900e-01   0   1   0   1   0");
//     fPythia->readString("431:addChannel = 1   0.0640000    0      -15       16");
//    }

// // find all long lived particles in pythia
//    Int_t n = 1;
//    while(n!=0){
//     n = fPythia->particleData.nextId(n);
//     ParticleDataEntry* p = fPythia->particleData.particleDataEntryPtr(n);
//     if (p->tau0()>1){
//      string particle = std::to_string(n)+":mayDecay = false";
//      fPythia->readString(particle);
//      fLogger->Info(MESSAGE_ORIGIN,"Made %s stable for Pythia, should decay in Geant4",p->name().c_str());
//     }
//    } 
// // boost branching fraction of rare di-muon decays
// //                       eta  omega rho0  eta' phi   
//    if (fBoost != 1.){
//     fLogger->Info(MESSAGE_ORIGIN,"Rescale BRs of dimuon decays in Pythia: %f",fBoost);
//     for (unsigned int i=0; i<r.size(); ++i) {  
//      Pythia8::ParticleDataEntry* V = fPythia->particleData.particleDataEntryPtr(r[i]);
//      Pythia8::DecayChannel ch = V->channel(c[i]);
//      if (TMath::Abs(ch.product(0))!=13 || TMath::Abs(ch.product(1))!=13){
//       fLogger->Info(MESSAGE_ORIGIN,"this is not the right decay channel: %i %i",r[i],c[i]);
//      }else{     
//      TString tmp="";
//      tmp+=r[i];tmp+=":";tmp+= c[i];
//      tmp+=":bRatio =";
//      tmp+=fBoost*ch.bRatio();
//      fPythia->readString(tmp.Data());
//      }
//     }
//    }
//    fPythia->init();
//   }
//   // Initialize EvtGen.
//   if (withEvtGen){
//    TString SIMPATH=getenv("SIMPATH");
//    TString DecayFile =SIMPATH+"/share/EvtGen/DECAY.DEC";
//    TString ParticleFile =SIMPATH + "/share/EvtGen/evt.pdl";
//    if(SIMPATH == "")
//      {
//        std::cout << "Using $EVTGENDATA "<< getenv("EVTGENDATA") << std::endl;
//        DecayFile =TString(getenv("EVTGENDATA"))+"/DECAY.DEC";
//        ParticleFile =TString(getenv("EVTGENDATA"))+ "/evt.pdl";
//      }
//    EvtAbsRadCorr *fsrPtrIn = 0;
//    EvtExternalGenList *extPtr = new EvtExternalGenList();
//    std::list<EvtDecayBase*> models = extPtr->getListOfModels();
//  // Define the random number generator
//    EvtRandomEngine* eng = new EvtSimpleRandomEngine();
//    EvtRandom::setRandomEngine(eng);
//    EvtGen *myEvtGenPtr = new EvtGen(DecayFile.Data(), ParticleFile.Data(),eng, fsrPtrIn, &models, 1, false);
//    TString UdecayFile    = getenv("FAIRSHIP");UdecayFile +="/gconfig/USERDECAY.DEC";
//    evtgenP = new EvtGenDecays(fPythiaP, DecayFile.Data(), ParticleFile.Data(),myEvtGenPtr);
//    evtgenP->readDecayFile(UdecayFile.Data()); // will make update of EvtGen with user decay file
//    // use one instance of EvtGen, requires patch to Pythia8Plugins/EvtGen.h
//    if (Option == "Primary"){
//     evtgenN = new EvtGenDecays(fPythiaN, DecayFile.Data(), ParticleFile.Data(),myEvtGenPtr);
//    }
//   }
//   if (targetName!=""){
//    fMaterialInvestigator = new GenieGenerator();
//    if (!fcharmtarget){   
//    TGeoNavigator* nav = gGeoManager->GetCurrentNavigator();
//    nav->cd(targetName);
//    TGeoNode* target = nav->GetCurrentNode(); 
//    TObjArray* nodes =  target->GetVolume()->GetNodes();
//    TGeoNode* first = (TGeoNode*)nodes->At(0);
//    Int_t ilast = nodes->GetSize()-5; // assumes that the last 5 nodes are for the shielding around the target.
//    TGeoNode* last  = (TGeoNode*)nodes->At(ilast);
//    nav->cd(targetName+"/"+first->GetName()); 
//    TGeoBBox* sha = (TGeoBBox*)first->GetVolume()->GetShape();
//    Double_t dz   = sha->GetDZ();
//    Double_t origin[3] = {0,0,-dz};
//    Double_t master[3] = {0,0,0};
//    nav->LocalToMaster(origin,master);
//    startZ =  master[2];
//    nav->cd(targetName+"/"+last->GetName()); 
//    sha = (TGeoBBox*)first->GetVolume()->GetShape();
//    dz   = sha->GetDZ();
//    origin[2] = +dz;
//    nav->LocalToMaster(origin,master);
//    endZ =  master[2];
//    start[0]=xOff;
//    start[1]=yOff;
//    start[2]=startZ;
//    end[0]=xOff;
//    end[1]=yOff;
//    end[2]=endZ;
//    }
//    else{  //charm geometry uses a different target 
//    TGeoVolume* top = gGeoManager->GetTopVolume();
//    TGeoNode* target = top->FindNode(targetName);
//    if (!target){
//        fLogger->Error(MESSAGE_ORIGIN,"target not found, %s, program will crash",targetName.Data());
//    }
//    Double_t z_middle = target->GetMatrix()->GetTranslation()[2];
//    TGeoBBox* sha = (TGeoBBox*)target->GetVolume()->GetShape();
//    startZ =  z_middle - sha->GetDZ();
//    endZ   =  z_middle + sha->GetDZ();
//    start[0]=xOff;
//    start[1]=yOff;
//    start[2]=startZ;
//    end[0]=xOff;
//    end[1]=yOff;
//    end[2]=endZ;
//    }
// //find maximum interaction length
//    bparam = fMaterialInvestigator->MeanMaterialBudget(start, end, mparam);
//    maxCrossSection =  mparam[9];
//   }

  return kTRUE;
}
// -------------------------------------------------------------------------


// -----   Destructor   ----------------------------------------------------
FixedTargetGenerator::~FixedTargetGenerator()
{
}
// -------------------------------------------------------------------------

// -----   Passing the event   ---------------------------------------------
Bool_t FixedTargetGenerator::ReadEvent(FairPrimaryGenerator* cpg)
{
  TDatabasePDG* pdgBase = TDatabasePDG::Instance();

Double_t mass,e,tof,phi;
Double_t dx = 0, dy = 0;

std::vector<int> muList;

//define variables to pull from tree
Double_t fUniquieID,fPdgCode,fMotherId,fPx,fPy,fPz,fM,fStartX,fStartY,fStartZ,fW,fProcID;

while (fn<fNevents)
{

  if (fn>fNevents)
  {
    std::cout << "3 " << fn <<"\n";
    fLogger->Info(MESSAGE_ORIGIN,"End of file reached %i",fNevents);
    return kFALSE;
  }


  fTree->SetBranchAddress("pythiaid",&fPdgCode);
  fTree->SetBranchAddress("mother_id",&fMotherId);
  fTree->SetBranchAddress("px",&fPx);
  fTree->SetBranchAddress("py",&fPy);
  fTree->SetBranchAddress("pz",&fPz);
  fTree->SetBranchAddress("x",&fStartX);
  fTree->SetBranchAddress("y",&fStartY);
  fTree->SetBranchAddress("z",&fStartZ);
  fTree->SetBranchAddress("w",&fW);
  fTree->SetBranchAddress("process_id",&fProcID);



  fTree->GetEntry(fn);

  if (fn % 1000 == 0)
  {
    std::cout << fn <<"\n";
  }
  //add track to simulation

Double_t r = 5 + 0.8 * gRandom->Gaus();
     Double_t phi = gRandom->Uniform(0., 2.) * TMath::Pi();
     dx = r * TMath::Cos(phi);
     dy = r * TMath::Sin(phi);

  // cpg->AddTrack(13,px2,py2,pz2,x2,y2,z2+2084.5,-1,true,ecut2,0,1);
  // cpg->AddTrack(13,px2,py2,pz2,x2,y2,z2,-1,true,ecut2,0,1);
  // std::cout << 13 <<" "<<px2<<" "<<py2<<" "<<pz2<<" "<<x2<<" "<<y2<<" "<<-6542<<" "<<-1<<" "<<true<<" "<<ecut2<<" "<<0<<" "<<1 <<"\n";
  // std::cout << "fStartZ" << fStartZ+216-144<<"\n";
  // std::cout << "fStartZ" << fStartZ+2228.5-144.0<<"\n";
  cpg->AddTrack(fPdgCode,fPx,fPy,fPz,fStartX+dx,fStartY+dy,fStartZ+216-144,-1,true,0,0,fW);

  fn++;

  return kTRUE;
}
//   Double_t zinter=0;
//   Double_t ZoverA = 1.;
//   if (targetName.Data() !=""){
// // calculate primary proton interaction point:
// // loop over trajectory between start and end to pick an interaction point, copied from GenieGenerator and adapted to hadrons
//    Double_t prob2int = -1.;
//    Double_t rndm = 0.;
//    Double_t sigma;
//    Int_t count=0;
//    Double_t zinterStart = start[2];
//    if (Option == "charm" || Option == "beauty"){ 
// // simulate more downstream interaction points for interactions down in the cascade
//     if (!(nTree->GetBranch("k"))){ck=1;}
//    }
//    else {ck=1;} 
//    while (ck>0.5){
//     while (prob2int<rndm) {
//  //place x,y,z uniform along path
//       zinter = gRandom->Uniform(zinterStart,end[2]);
//       Double_t point[3]={xOff,yOff,zinter};
//       bparam = fMaterialInvestigator->MeanMaterialBudget(start, point, mparam);
//       Double_t interLength = mparam[8]; 
//       TGeoNode *node = gGeoManager->FindNode(point[0],point[1],point[2]);
//       TGeoMaterial *mat = 0;
//       if (node && !gGeoManager->IsOutside()) {
//          mat = node->GetVolume()->GetMaterial();
//          Double_t n = mat->GetDensity()/mat->GetA();
//          ZoverA =  mat->GetZ() / mat->GetA();
//          sigma = 1./(n*mat->GetIntLen())/mbarn;
//          prob2int = TMath::Exp(-interLength)*sigma/maxCrossSection;
//       }else{
//          prob2int=0.;
//       }
//       rndm = gRandom->Uniform(0.,1.); 
//       count+=1;
//     }
//     zinterStart = zinter;
//     ck-=1;
//   } 
//   zinter = zinter*cm;
//   }
//   Pythia8::Pythia* fPythia;
//   if (G4only){
//    cpg->AddTrack(2212,0.,0.,fMom,xOff/cm,yOff/cm,start[2],-1,kTRUE,-1.,0.,1.);
//    return kTRUE;
//   }else if (Option == "Primary"){
//    if (gRandom->Uniform(0.,1.) < ZoverA ){
//     fPythiaP->next();
//     if (withEvtGen){evtgenP->decay();}
//     fPythia = fPythiaP;
//    }else{
//     fPythiaN->next();
//     if (withEvtGen){evtgenN->decay();}
//     fPythia = fPythiaN;
//    }
//   }else{
//     if (nEntry==nEvents){
//       fLogger->Info(MESSAGE_ORIGIN,"Rewind input file: %i",nEntry);
//       nEntry=0;}
//     nTree->GetEvent(nEntry);
//     nEntry+=1;
//     // sanity check, count number of p.o.t. on input file.
//     Double_t pt=TMath::Sqrt( (n_mpx*n_mpx)+(n_mpy*n_mpy));
//     // every event appears twice, i.e.
//     if (pt<1.e-5 && n_mid==2212){ 
//      pot+=+0.5;
//      ntotprim+=1;}
//     Int_t idabs=int(TMath::Abs(n_id));
//     if (idabs==431){ nDsprim+=1;}
//     fPythiaP->event.reset();
//     fPythiaP->event.append(int(n_id),1,0,0,n_px,n_py,n_pz,n_E,n_M,0.,9.);
//     TMCProcess procID  = kPTransportation;
//     if (n_mid==2212 && (n_mpx*n_mpx+n_mpy*n_mpy)<1E-5) {procID = kPPrimary;} // probably primary and not from cascade
//     cpg->AddTrack(int(n_mid),n_mpx,n_mpy,n_mpz, xOff/cm,yOff/cm,zinter/cm,-1,kFALSE,n_mE,0.,wspill,procID);
//     fPythiaP->next();
//     fPythia = fPythiaP;
//   }
//   if (withEvtGen){
//    fPythia->moreDecays();} // let the very short lived resonances decay via Pythia8
//   if(Debug && !G4only){fPythia->event.list();}
//   TMCProcess procID; 
//   for(Int_t ii=1; ii<fPythia->event.size(); ii++){
//      Double_t  e = fPythia->event[ii].e();
//      Double_t  m = fPythia->event[ii].m();
//      Double_t pz = fPythia->event[ii].pz();
//      Int_t id = fPythia->event[ii].id(); 
//      Bool_t wanttracking=kTRUE;
//      if (e-m<EMax || !fPythia->event[ii].isFinal() || pz<0) {wanttracking=kFALSE;}
//      Double_t z  = fPythia->event[ii].zProd()+zinter;
//      Double_t x  = fPythia->event[ii].xProd()+xOff;
//      Double_t y  = fPythia->event[ii].yProd()+yOff;
//      Double_t tof = fPythia->event[ii].tProd() / (10*c_light) ; // to go from mm to s
//      Double_t px = fPythia->event[ii].px();  
//      Double_t py = fPythia->event[ii].py();  
//      Int_t im = fPythia->event[ii].mother1()-1;
//      procID = kPPrimary;
//      if (Option != "Primary"){
//         procID = kPDecay;
//         im+=1;
//         if (ii==1) {procID  = kPHadronic;}
//      }else{
//       if (ii<3){im=-1;}
//      }
//      cpg->AddTrack(id,px,py,pz,x/cm,y/cm,z/cm,im,wanttracking,e,tof,wspill,procID);
//     }    
//   return kTRUE;
}
// -------------------------------------------------------------------------

ClassImp(FixedTargetGenerator)
