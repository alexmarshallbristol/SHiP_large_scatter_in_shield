#include "ShipMuonShield.h"

#include "TGeoManager.h"
#include "TObjArray.h"                  // for TObjArray
#include "TString.h"                    // for TString
#include "TGeoBBox.h"
#include "TGeoTrd1.h"
#include "TGeoCompositeShape.h"
#include "TGeoBoolNode.h"
#include "TGeoTube.h"
#include "TGeoMaterial.h"
#include "FairGeoInterface.h"
#include "FairGeoMedia.h"
#include "FairGeoBuilder.h"
#include "FairRuntimeDb.h"              // for FairRuntimeDb
#include "TVectorT.h"
#include "TFile.h"
#include <iostream>    
#include <string>                 // for operator<<, basic_ostream, etc
using std::cout;
using std::endl;
Double_t cm = 1;
Double_t m = 100 * cm;
Double_t mm = 0.1 * cm;
Double_t kilogauss = 1.;
Double_t tesla = 10 * kilogauss;

ShipMuonShield::~ShipMuonShield() {}
ShipMuonShield::ShipMuonShield() : FairModule("ShipMuonShield", "") {}

ShipMuonShield::ShipMuonShield(TString geofile)
  : FairModule("MuonShield", "ShipMuonShield")
{
  fGeofile = geofile;
  auto f = TFile::Open(geofile, "read");
  TVectorT<Double_t> params;
  params.Read("params");
  Double_t LE = 10. * m, floor = 5. * m;
  fDesign = 8;
  fField = 1.7;
  dZ0 = 1 * m;
  dZ1 = 0.4 * m;
  dZ2 = 2.31 * m;
  dZ3 = params[2];
  dZ4 = params[3];
  dZ5 = params[4];
  dZ6 = params[5];
  dZ7 = params[6];
  dZ8 = params[7];
  fMuonShieldLength = 2 * (dZ1 + dZ2 + dZ3 + dZ4 + dZ5 + dZ6 + dZ7 + dZ8) + LE;

  fFloor = floor;
  fSupport = true;

  Double_t Z = -25 * m - fMuonShieldLength / 2.;

  zEndOfAbsorb = Z + dZ0 - fMuonShieldLength / 2.;
  zEndOfAbsorb -= dZ0;
}

ShipMuonShield::ShipMuonShield(const char* name, const Int_t Design, const char* Title,
                               Double_t Z, Double_t L0, Double_t L1, Double_t L2, Double_t L3, Double_t L4, Double_t L5, Double_t L6,
                               Double_t L7, Double_t L8, Double_t gap, Double_t LE, Double_t, Double_t floor, Double_t field)
  : FairModule(name ,Title)
{
 fDesign = Design;
 // fz_sens_plane_position = z_sens_plane_position;
 fField  = field;
 fGeofile = "";
 if (fDesign==1){
     fMuonShieldLength = L1;   
    }
 if (fDesign==2 || fDesign==3 || fDesign==4 ){
     Fatal("ShipMuonShield","Design %i not anymore supported",fDesign);
    }
 if (fDesign==5 || fDesign==6){
     dZ0 = L0;
     dZ1 = L1;
     dZ2 = L2;
     dZ3 = L3;
     dZ4 = L4;
     dZ5 = L5;
     dZ6 = L6;
     dZ7 = L7;
     dZ8 = L8;
     dXgap= gap;
     fMuonShieldLength = 2*(dZ1+dZ2+dZ3+dZ4+dZ5+dZ6+dZ7+dZ8) + LE ; //leave some space for nu-tau detector   
    }
    
 if (fDesign>=7){
     dZ1 = L1;
     dZ2 = L2;
     dZ3 = L3;
     dZ4 = L4;
     dZ5 = L5;
     dZ6 = L6;
     dZ7 = L7;
     dZ8 = L8;
     fMuonShieldLength =
   2 * (dZ1 + dZ2 + dZ3 + dZ4 + dZ5 + dZ6 + dZ7 + dZ8) + LE;
   }
    
 fFloor = (fDesign >= 7) ? floor : 0;

 zEndOfAbsorb = Z + dZ0 - fMuonShieldLength/2.;   
 if(fDesign>=6){zEndOfAbsorb = Z - fMuonShieldLength/2.;}
 fSupport = true;
}

// -----   Private method InitMedium 
Int_t ShipMuonShield::InitMedium(TString name) 
{
   static FairGeoLoader *geoLoad=FairGeoLoader::Instance();
   static FairGeoInterface *geoFace=geoLoad->getGeoInterface();
   static FairGeoMedia *media=geoFace->getMedia();
   static FairGeoBuilder *geoBuild=geoLoad->getGeoBuilder();

   FairGeoMedium *ShipMedium=media->getMedium(name);

   if (!ShipMedium)
     Fatal("InitMedium","Material %s not defined in media file.", name.Data());
   TGeoMedium* medium=gGeoManager->GetMedium(name);
   if (medium)
     return ShipMedium->getMediumIndex();
   return geoBuild->createMedium(ShipMedium);
}

void ShipMuonShield::CreateTube(TString tubeName, TGeoMedium *medium,
        Double_t dX, Double_t dY, Double_t dZ,
        Int_t color, TGeoVolume *tShield,
        Double_t x_translation, Double_t y_translation,
        Double_t z_translation) {
  TGeoVolume *absorber = gGeoManager->MakeTube(tubeName, medium, dX, dY, dZ);
  absorber->SetLineColor(color);
  cout << "132" << tubeName << z_translation << endl;
  tShield->AddNode(
      absorber, 1,
      new TGeoTranslation(x_translation, y_translation, z_translation));
}

void ShipMuonShield::CreateArb8(TString arbName, TGeoMedium *medium,
        Double_t dZ, std::array<Double_t, 16> corners,
        Int_t color, TGeoUniformMagField *magField,
        TGeoVolume *tShield, Double_t x_translation,
        Double_t y_translation,
        Double_t z_translation, Double_t z_sens_plane) {
  TGeoVolume *magF =
      gGeoManager->MakeArb8(arbName, medium, dZ, corners.data());





  magF->SetLineColor(color);
  magF->SetField(magField);
  // cout << "147" << arbName << z_translation << endl;

  // Double_t z_sens_plane=-5420;
  // Double_t z_sens_plane=0;

  // if arbName == "MagnAbsorb2":

if (arbName.Contains("MagnAbsorb2") == true) 
{
  // std::cout << z_sens_plane<<"found!" << '\n';
  // if sensplane is after the end of one add the node
  if (z_sens_plane > -6542)
  {
    tShield->AddNode(magF, 1, new TGeoTranslation(x_translation, y_translation,
            z_translation));
  }
  else
  {
    if (z_sens_plane > -6994)
    {
      std::cout << "IT IS SOMEWHERE IN THIS MAGNET " << arbName << " " << z_sens_plane<<"found!" << '\n';
      tShield->AddNode(magF, 1, new TGeoTranslation(x_translation, y_translation,
            z_translation));
    }
  }
}





if (arbName.Contains("Magn1") == true) 
{
  // std::cout << z_sens_plane<<"found!" << '\n';
  // if sensplane is after the end of one add the node
  if (z_sens_plane > -6106)
  {
    tShield->AddNode(magF, 1, new TGeoTranslation(x_translation, y_translation,
            z_translation));
  }
  else
  {
    if (z_sens_plane > -6522)
    {
      std::cout << "IT IS SOMEWHERE IN THIS MAGNET " << arbName << " " << z_sens_plane<<"found!" << '\n';
      tShield->AddNode(magF, 1, new TGeoTranslation(x_translation, y_translation,
            z_translation));
    }
  }
}



if (arbName.Contains("Magn2") == true) 
{
  // std::cout << z_sens_plane<<"found!" << '\n';
  // if sensplane is after the end of one add the node
  if (z_sens_plane > -5682)
  {
    tShield->AddNode(magF, 1, new TGeoTranslation(x_translation, y_translation,
            z_translation));
  }
  else
  {
    if (z_sens_plane > -6096)
    {
      std::cout << "IT IS SOMEWHERE IN THIS MAGNET " << arbName << " " << z_sens_plane<<"found!" << '\n';
      tShield->AddNode(magF, 1, new TGeoTranslation(x_translation, y_translation,
            z_translation));
    }
  }
}


if (arbName.Contains("Magn3") == true) 
{
  // std::cout << z_sens_plane<<"found!" << '\n';
  // if sensplane is after the end of one add the node
  if (z_sens_plane > -5110)
  {
    tShield->AddNode(magF, 1, new TGeoTranslation(x_translation, y_translation,
            z_translation));
  }
  else
  {
    if (z_sens_plane > -5672)
    {
      std::cout << "IT IS SOMEWHERE IN THIS MAGNET " << arbName << " " << z_sens_plane<<"found!" << '\n';
      tShield->AddNode(magF, 1, new TGeoTranslation(x_translation, y_translation,
            z_translation));
    }
  }
}



if (arbName.Contains("Magn4") == true) 
{
  // std::cout << z_sens_plane<<"found!" << '\n';
  // if sensplane is after the end of one add the node
  if (z_sens_plane > -4604)
  {
    tShield->AddNode(magF, 1, new TGeoTranslation(x_translation, y_translation,
            z_translation));
  }
  else
  {
    if (z_sens_plane > -5100)
    {
      std::cout << "IT IS SOMEWHERE IN THIS MAGNET " << arbName << " " << z_sens_plane<<"found!" << '\n';
      tShield->AddNode(magF, 1, new TGeoTranslation(x_translation, y_translation,
            z_translation));
    }
  }
}


if (arbName.Contains("Magn5") == true) 
{
  // std::cout << z_sens_plane<<"found!" << '\n';
  // if sensplane is after the end of one add the node
  if (z_sens_plane > -3984)
  {
    tShield->AddNode(magF, 1, new TGeoTranslation(x_translation, y_translation,
            z_translation));
  }
  else
  {
    if (z_sens_plane > -4594)
    {
      std::cout << "IT IS SOMEWHERE IN THIS MAGNET " << arbName << " " << z_sens_plane<<"found!" << '\n';
      tShield->AddNode(magF, 1, new TGeoTranslation(x_translation, y_translation,
            z_translation));
    }
  }
}


if (arbName.Contains("Magn6") == true) 
{
  // std::cout << z_sens_plane<<"found!" << '\n';
  // if sensplane is after the end of one add the node
  if (z_sens_plane > -3490)
  {
    tShield->AddNode(magF, 1, new TGeoTranslation(x_translation, y_translation,
            z_translation));
  }
  else
  {
    if (z_sens_plane > -3974)
    {
      std::cout << "IT IS SOMEWHERE IN THIS MAGNET " << arbName << " " << z_sens_plane<<"found!" << '\n';
      tShield->AddNode(magF, 1, new TGeoTranslation(x_translation, y_translation,
            z_translation));
    }
  }
}


if (arbName.Contains("Magn7") == true) 
{
  // std::cout << z_sens_plane<<"found!" << '\n';
  // if sensplane is after the end of one add the node
  if (z_sens_plane > -3470)
  {
    tShield->AddNode(magF, 1, new TGeoTranslation(x_translation, y_translation,
            z_translation));
  }
  else
  {
    if (z_sens_plane > -3490)
    {
      std::cout << "IT IS SOMEWHERE IN THIS MAGNET " << arbName << " " << z_sens_plane<<"found!" << '\n';
      tShield->AddNode(magF, 1, new TGeoTranslation(x_translation, y_translation,
            z_translation));
    }
  }
}


  // tShield->AddNode(magF, 1, new TGeoTranslation(x_translation, y_translation,
    //        z_translation));
}

void ShipMuonShield::CreateMagnet(TString magnetName,TGeoMedium* medium,TGeoVolume *tShield,TGeoUniformMagField *fields[4],FieldDirection fieldDirection,
          Double_t dX, Double_t dY, Double_t dX2, Double_t dY2, Double_t dZ,
          Double_t middleGap,Double_t middleGap2,
          Double_t HmainSideMag, Double_t HmainSideMag2,
          Double_t gap,Double_t gap2, Double_t Z, Bool_t NotMagnet)
  {

    cout << " " << endl;
    cout << magnetName << " " << dX << " " << dY << " " << dX2 << " " << dY2 << " " << dZ << " " << middleGap << " " << middleGap2 << " " << HmainSideMag << " " << HmainSideMag2 << " " << endl;



    Double_t coil_gap,coil_gap2;
    Int_t color[4] = {45,31,30,38};

    if (NotMagnet) {
       coil_gap = gap;
       coil_gap2 = gap2;
    } else if (fDesign > 7) {
       // Assuming 0.5A/mm^2 and 10000At needed, about 200cm^2 gaps are necessary
       // Current design safely above this. Will consult with MISiS to get a better minimum.
       gap = std::ceil(std::max(100. / dY, gap));
       gap2 = std::ceil(std::max(100. / dY2, gap2));
       coil_gap = gap;
       coil_gap2 = gap2;
    } else {
       coil_gap = std::max(20., gap);
       coil_gap2 = std::max(20., gap2);
       gap = std::max(2., gap);
       gap2 = std::max(2., gap2);
    }

    Double_t anti_overlap = (fDesign == 5) ? 0.0 : 0.1; // gap between fields in the
               // corners for mitred joints
               // (Geant goes crazy when
               // they touch each other)


    Int_t fraction_of_magnet = 0;

    //change all here
    // Double_t z_sens_plane=-5420;
    Double_t z_sens_plane=